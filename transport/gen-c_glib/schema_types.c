/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "schema_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_Crud_operation_TRANSPORT(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case CRUD_OPERATION__T_R_A_N_S_P_O_R_T_CRUD_GET:return "CRUD_OPERATION__T_R_A_N_S_P_O_R_T_CRUD_GET";
  case CRUD_OPERATION__T_R_A_N_S_P_O_R_T_CRUD_REMOVE:return "CRUD_OPERATION__T_R_A_N_S_P_O_R_T_CRUD_REMOVE";
  case CRUD_OPERATION__T_R_A_N_S_P_O_R_T_CRUD_NEW:return "CRUD_OPERATION__T_R_A_N_S_P_O_R_T_CRUD_NEW";
  case CRUD_OPERATION__T_R_A_N_S_P_O_R_T_CRUD_UPDATE:return "CRUD_OPERATION__T_R_A_N_S_P_O_R_T_CRUD_UPDATE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Condition_code_TRANSPORT(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_EQUAL:return "CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_EQUAL";
  case CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_GREATER:return "CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_GREATER";
  case CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_LESS:return "CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_LESS";
  case CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_NOT_GREATER:return "CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_NOT_GREATER";
  case CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_NOT_LESS:return "CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_NOT_LESS";
  case CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_SUBSTR:return "CONDITION_CODE__T_R_A_N_S_P_O_R_T_OP_SUBSTR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Logic_op_TRANSPORT(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case LOGIC_OP__T_R_A_N_S_P_O_R_T_OP_AND:return "LOGIC_OP__T_R_A_N_S_P_O_R_T_OP_AND";
  case LOGIC_OP__T_R_A_N_S_P_O_R_T_OP_OR:return "LOGIC_OP__T_R_A_N_S_P_O_R_T_OP_OR";
  case LOGIC_OP__T_R_A_N_S_P_O_R_T_OP_NOT:return "LOGIC_OP__T_R_A_N_S_P_O_R_T_OP_NOT";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Type_TRANSPORT(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case TYPE__T_R_A_N_S_P_O_R_T_STRING_TYPE:return "TYPE__T_R_A_N_S_P_O_R_T_STRING_TYPE";
  case TYPE__T_R_A_N_S_P_O_R_T_INTEGER_TYPE:return "TYPE__T_R_A_N_S_P_O_R_T_INTEGER_TYPE";
  case TYPE__T_R_A_N_S_P_O_R_T_BOOLEAN_TYPE:return "TYPE__T_R_A_N_S_P_O_R_T_BOOLEAN_TYPE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _Value_union_TRANSPORTProperties
{
  PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_0,
  PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_INTEGER,
  PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_BOOLEAN,
  PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_STRING
};

/* reads a value_union__t_r_a_n_s_p_o_r_t object */
static gint32
value_union__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Value_union_TRANSPORT * this_object = VALUE_UNION__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->Integer, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_Integer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->Boolean, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_Boolean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->String != NULL)
          {
            g_free(this_object->String);
            this_object->String = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->String, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_String = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
value_union__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Value_union_TRANSPORT * this_object = VALUE_UNION__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Value_union_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_Integer == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "Integer", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->Integer, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_Boolean == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "Boolean", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->Boolean, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_String == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "String", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->String, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
value_union__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  Value_union_TRANSPORT *self = VALUE_UNION__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_INTEGER:
      self->Integer = g_value_get_int (value);
      self->__isset_Integer = TRUE;
      break;

    case PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_BOOLEAN:
      self->Boolean = g_value_get_boolean (value);
      self->__isset_Boolean = TRUE;
      break;

    case PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_STRING:
      if (self->String != NULL)
        g_free (self->String);
      self->String = g_value_dup_string (value);
      self->__isset_String = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
value_union__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  Value_union_TRANSPORT *self = VALUE_UNION__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_INTEGER:
      g_value_set_int (value, self->Integer);
      break;

    case PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_BOOLEAN:
      g_value_set_boolean (value, self->Boolean);
      break;

    case PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_STRING:
      g_value_set_string (value, self->String);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
value_union__t_r_a_n_s_p_o_r_t_instance_init (Value_union_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->Integer = 0;
  object->__isset_Integer = FALSE;
  object->Boolean = 0;
  object->__isset_Boolean = FALSE;
  object->String = NULL;
  object->__isset_String = FALSE;
}

static void 
value_union__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Value_union_TRANSPORT *tobject = VALUE_UNION__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->String != NULL)
  {
    g_free(tobject->String);
    tobject->String = NULL;
  }
}

static void
value_union__t_r_a_n_s_p_o_r_t_class_init (Value_union_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = value_union__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = value_union__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = value_union__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = value_union__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = value_union__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_INTEGER,
     g_param_spec_int ("Integer",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_BOOLEAN,
     g_param_spec_boolean ("Boolean",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE_UNION__T_R_A_N_S_P_O_R_T_STRING,
     g_param_spec_string ("String",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
value_union__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Value_union_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) value_union__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Value_union_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) value_union__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Value_union_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Value_TRANSPORTProperties
{
  PROP_VALUE__T_R_A_N_S_P_O_R_T_0,
  PROP_VALUE__T_R_A_N_S_P_O_R_T_TYPE,
  PROP_VALUE__T_R_A_N_S_P_O_R_T_VALUE
};

/* reads a value__t_r_a_n_s_p_o_r_t object */
static gint32
value__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Value_TRANSPORT * this_object = VALUE__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (Type_TRANSPORT)ecast0;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
value__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Value_TRANSPORT * this_object = VALUE__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Value_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
value__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  Value_TRANSPORT *self = VALUE__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_VALUE__T_R_A_N_S_P_O_R_T_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_VALUE__T_R_A_N_S_P_O_R_T_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
value__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  Value_TRANSPORT *self = VALUE__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_VALUE__T_R_A_N_S_P_O_R_T_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_VALUE__T_R_A_N_S_P_O_R_T_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
value__t_r_a_n_s_p_o_r_t_instance_init (Value_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->value = g_object_new (TYPE_VALUE_UNION__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_value = FALSE;
}

static void 
value__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Value_TRANSPORT *tobject = VALUE__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
value__t_r_a_n_s_p_o_r_t_class_init (Value_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = value__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = value__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = value__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = value__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = value__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE__T_R_A_N_S_P_O_R_T_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE__T_R_A_N_S_P_O_R_T_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_VALUE_UNION__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));
}

GType
value__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Value_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) value__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Value_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) value__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Value_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Native_filter_TRANSPORTProperties
{
  PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_0,
  PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_NAME,
  PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_OPCODE,
  PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_VALUE
};

/* reads a native_filter__t_r_a_n_s_p_o_r_t object */
static gint32
native_filter__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Native_filter_TRANSPORT * this_object = NATIVE_FILTER__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast1;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->opcode = (Condition_code_TRANSPORT)ecast1;
          this_object->__isset_opcode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
native_filter__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Native_filter_TRANSPORT * this_object = NATIVE_FILTER__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Native_filter_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "opcode", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->opcode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
native_filter__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  Native_filter_TRANSPORT *self = NATIVE_FILTER__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_OPCODE:
      self->opcode = g_value_get_int (value);
      self->__isset_opcode = TRUE;
      break;

    case PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
native_filter__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  Native_filter_TRANSPORT *self = NATIVE_FILTER__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_OPCODE:
      g_value_set_int (value, self->opcode);
      break;

    case PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
native_filter__t_r_a_n_s_p_o_r_t_instance_init (Native_filter_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->__isset_opcode = FALSE;
  object->value = g_object_new (TYPE_VALUE__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_value = FALSE;
}

static void 
native_filter__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Native_filter_TRANSPORT *tobject = NATIVE_FILTER__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
native_filter__t_r_a_n_s_p_o_r_t_class_init (Native_filter_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = native_filter__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = native_filter__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = native_filter__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = native_filter__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = native_filter__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_OPCODE,
     g_param_spec_int ("opcode",
                       NULL,
                       NULL,
                       0,
                       5,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NATIVE_FILTER__T_R_A_N_S_P_O_R_T_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_VALUE__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));
}

GType
native_filter__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Native_filter_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) native_filter__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Native_filter_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) native_filter__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Native_filter_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Logic_func_TRANSPORTProperties
{
  PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_0,
  PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_TYPE,
  PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_FILTERS
};

/* reads a logic_func__t_r_a_n_s_p_o_r_t object */
static gint32
logic_func__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Logic_func_TRANSPORT * this_object = LOGIC_FUNC__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast2;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (Logic_op_TRANSPORT)ecast2;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Filter_TRANSPORT * _elem3 = NULL;
              if ( _elem3 != NULL)
              {
                g_object_unref (_elem3);
              }
              _elem3 = g_object_new (TYPE_FILTER__T_R_A_N_S_P_O_R_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem3), protocol, error)) < 0)
              {
                g_object_unref (_elem3);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->filters, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_filters = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
logic_func__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Logic_func_TRANSPORT * this_object = LOGIC_FUNC__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Logic_func_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "filters", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i4;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->filters ? this_object->filters->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i4 = 0; i4 < (this_object->filters ? this_object->filters->len : 0); i4++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->filters, i4))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
logic_func__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  Logic_func_TRANSPORT *self = LOGIC_FUNC__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_FILTERS:
      if (self->filters != NULL)
        g_ptr_array_unref (self->filters);
      self->filters = g_value_dup_boxed (value);
      self->__isset_filters = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
logic_func__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  Logic_func_TRANSPORT *self = LOGIC_FUNC__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_FILTERS:
      g_value_set_boxed (value, self->filters);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
logic_func__t_r_a_n_s_p_o_r_t_instance_init (Logic_func_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->filters = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_filters = FALSE;
}

static void 
logic_func__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Logic_func_TRANSPORT *tobject = LOGIC_FUNC__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->filters != NULL)
  {
    g_ptr_array_unref (tobject->filters);
    tobject->filters = NULL;
  }
}

static void
logic_func__t_r_a_n_s_p_o_r_t_class_init (Logic_func_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = logic_func__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = logic_func__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = logic_func__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = logic_func__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = logic_func__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGIC_FUNC__T_R_A_N_S_P_O_R_T_FILTERS,
     g_param_spec_boxed ("filters",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
logic_func__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Logic_func_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) logic_func__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Logic_func_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) logic_func__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Logic_func_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Filter_union_TRANSPORTProperties
{
  PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_0,
  PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_FUNC,
  PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_FILTER
};

/* reads a filter_union__t_r_a_n_s_p_o_r_t object */
static gint32
filter_union__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Filter_union_TRANSPORT * this_object = FILTER_UNION__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->func), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_func = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
filter_union__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Filter_union_TRANSPORT * this_object = FILTER_UNION__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Filter_union_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_func == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "func", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->func), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_filter == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
filter_union__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  Filter_union_TRANSPORT *self = FILTER_UNION__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_FUNC:
      if (self->func != NULL)
        g_object_unref (self->func);
      self->func = g_value_dup_object (value);
      self->__isset_func = TRUE;
      break;

    case PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
filter_union__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  Filter_union_TRANSPORT *self = FILTER_UNION__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_FUNC:
      g_value_set_object (value, self->func);
      break;

    case PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_FILTER:
      g_value_set_object (value, self->filter);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
filter_union__t_r_a_n_s_p_o_r_t_instance_init (Filter_union_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->func = g_object_new (TYPE_LOGIC_FUNC__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_func = FALSE;
  object->filter = g_object_new (TYPE_NATIVE_FILTER__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_filter = FALSE;
}

static void 
filter_union__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Filter_union_TRANSPORT *tobject = FILTER_UNION__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->func != NULL)
  {
    g_object_unref(tobject->func);
    tobject->func = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
}

static void
filter_union__t_r_a_n_s_p_o_r_t_class_init (Filter_union_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = filter_union__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = filter_union__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = filter_union__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = filter_union__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = filter_union__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_FUNC,
     g_param_spec_object ("func",
                         NULL,
                         NULL,
                         TYPE_LOGIC_FUNC__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILTER_UNION__T_R_A_N_S_P_O_R_T_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_NATIVE_FILTER__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));
}

GType
filter_union__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Filter_union_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) filter_union__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Filter_union_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) filter_union__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Filter_union_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Filter_TRANSPORTProperties
{
  PROP_FILTER__T_R_A_N_S_P_O_R_T_0,
  PROP_FILTER__T_R_A_N_S_P_O_R_T_IS_NATIVE,
  PROP_FILTER__T_R_A_N_S_P_O_R_T_FILTER
};

/* reads a filter__t_r_a_n_s_p_o_r_t object */
static gint32
filter__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Filter_TRANSPORT * this_object = FILTER__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->is_native, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_native = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
filter__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Filter_TRANSPORT * this_object = FILTER__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Filter_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_native", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->is_native, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
filter__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  Filter_TRANSPORT *self = FILTER__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_FILTER__T_R_A_N_S_P_O_R_T_IS_NATIVE:
      self->is_native = g_value_get_int (value);
      self->__isset_is_native = TRUE;
      break;

    case PROP_FILTER__T_R_A_N_S_P_O_R_T_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
filter__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  Filter_TRANSPORT *self = FILTER__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_FILTER__T_R_A_N_S_P_O_R_T_IS_NATIVE:
      g_value_set_int (value, self->is_native);
      break;

    case PROP_FILTER__T_R_A_N_S_P_O_R_T_FILTER:
      g_value_set_object (value, self->filter);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
filter__t_r_a_n_s_p_o_r_t_instance_init (Filter_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_native = 0;
  object->__isset_is_native = FALSE;
  object->filter = g_object_new (TYPE_FILTER_UNION__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_filter = FALSE;
}

static void 
filter__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Filter_TRANSPORT *tobject = FILTER__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
}

static void
filter__t_r_a_n_s_p_o_r_t_class_init (Filter_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = filter__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = filter__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = filter__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = filter__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = filter__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FILTER__T_R_A_N_S_P_O_R_T_IS_NATIVE,
     g_param_spec_int ("is_native",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILTER__T_R_A_N_S_P_O_R_T_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_FILTER_UNION__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));
}

GType
filter__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Filter_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) filter__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Filter_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) filter__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Filter_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Native_field_TRANSPORTProperties
{
  PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_0,
  PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_NAME,
  PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_VALUE
};

/* reads a native_field__t_r_a_n_s_p_o_r_t object */
static gint32
native_field__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Native_field_TRANSPORT * this_object = NATIVE_FIELD__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
native_field__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Native_field_TRANSPORT * this_object = NATIVE_FIELD__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Native_field_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
native_field__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  Native_field_TRANSPORT *self = NATIVE_FIELD__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
native_field__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  Native_field_TRANSPORT *self = NATIVE_FIELD__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
native_field__t_r_a_n_s_p_o_r_t_instance_init (Native_field_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->value = g_object_new (TYPE_VALUE__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_value = FALSE;
}

static void 
native_field__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Native_field_TRANSPORT *tobject = NATIVE_FIELD__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
native_field__t_r_a_n_s_p_o_r_t_class_init (Native_field_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = native_field__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = native_field__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = native_field__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = native_field__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = native_field__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NATIVE_FIELD__T_R_A_N_S_P_O_R_T_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_VALUE__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));
}

GType
native_field__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Native_field_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) native_field__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Native_field_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) native_field__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Native_field_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Header_TRANSPORTProperties
{
  PROP_HEADER__T_R_A_N_S_P_O_R_T_0,
  PROP_HEADER__T_R_A_N_S_P_O_R_T_TAG,
  PROP_HEADER__T_R_A_N_S_P_O_R_T_FILTER
};

/* reads a header__t_r_a_n_s_p_o_r_t object */
static gint32
header__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Header_TRANSPORT * this_object = HEADER__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tag != NULL)
          {
            g_free(this_object->tag);
            this_object->tag = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tag, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
header__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Header_TRANSPORT * this_object = HEADER__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Header_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tag", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tag, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
header__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  Header_TRANSPORT *self = HEADER__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_HEADER__T_R_A_N_S_P_O_R_T_TAG:
      if (self->tag != NULL)
        g_free (self->tag);
      self->tag = g_value_dup_string (value);
      self->__isset_tag = TRUE;
      break;

    case PROP_HEADER__T_R_A_N_S_P_O_R_T_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
header__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  Header_TRANSPORT *self = HEADER__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_HEADER__T_R_A_N_S_P_O_R_T_TAG:
      g_value_set_string (value, self->tag);
      break;

    case PROP_HEADER__T_R_A_N_S_P_O_R_T_FILTER:
      g_value_set_object (value, self->filter);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
header__t_r_a_n_s_p_o_r_t_instance_init (Header_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tag = NULL;
  object->__isset_tag = FALSE;
  object->filter = g_object_new (TYPE_FILTER__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_filter = FALSE;
}

static void 
header__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Header_TRANSPORT *tobject = HEADER__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tag != NULL)
  {
    g_free(tobject->tag);
    tobject->tag = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
}

static void
header__t_r_a_n_s_p_o_r_t_class_init (Header_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = header__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = header__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = header__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = header__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = header__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_HEADER__T_R_A_N_S_P_O_R_T_TAG,
     g_param_spec_string ("tag",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_HEADER__T_R_A_N_S_P_O_R_T_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_FILTER__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));
}

GType
header__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Header_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) header__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Header_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) header__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Header_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Related_node_TRANSPORTProperties
{
  PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_0,
  PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_HEADER,
  PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_FIELD_NAMES
};

/* reads a related_node__t_r_a_n_s_p_o_r_t object */
static gint32
related_node__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Related_node_TRANSPORT * this_object = RELATED_NODE__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->header), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_header = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem5 = NULL;
              if (_elem5 != NULL)
              {
                g_free(_elem5);
                _elem5 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem5, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->field_names, _elem5);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_field_names = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
related_node__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Related_node_TRANSPORT * this_object = RELATED_NODE__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Related_node_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "header", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->header), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field_names", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i6;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->field_names ? this_object->field_names->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i6 = 0; i6 < (this_object->field_names ? this_object->field_names->len : 0); i6++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->field_names, i6)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
related_node__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  Related_node_TRANSPORT *self = RELATED_NODE__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_HEADER:
      if (self->header != NULL)
        g_object_unref (self->header);
      self->header = g_value_dup_object (value);
      self->__isset_header = TRUE;
      break;

    case PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_FIELD_NAMES:
      if (self->field_names != NULL)
        g_ptr_array_unref (self->field_names);
      self->field_names = g_value_dup_boxed (value);
      self->__isset_field_names = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
related_node__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  Related_node_TRANSPORT *self = RELATED_NODE__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_HEADER:
      g_value_set_object (value, self->header);
      break;

    case PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_FIELD_NAMES:
      g_value_set_boxed (value, self->field_names);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
related_node__t_r_a_n_s_p_o_r_t_instance_init (Related_node_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->header = g_object_new (TYPE_HEADER__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_header = FALSE;
  object->field_names = g_ptr_array_new_with_free_func (g_free);
  object->__isset_field_names = FALSE;
}

static void 
related_node__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Related_node_TRANSPORT *tobject = RELATED_NODE__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->header != NULL)
  {
    g_object_unref(tobject->header);
    tobject->header = NULL;
  }
  if (tobject->field_names != NULL)
  {
    g_ptr_array_unref (tobject->field_names);
    tobject->field_names = NULL;
  }
}

static void
related_node__t_r_a_n_s_p_o_r_t_class_init (Related_node_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = related_node__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = related_node__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = related_node__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = related_node__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = related_node__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_HEADER,
     g_param_spec_object ("header",
                         NULL,
                         NULL,
                         TYPE_HEADER__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_NODE__T_R_A_N_S_P_O_R_T_FIELD_NAMES,
     g_param_spec_boxed ("field_names",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
related_node__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Related_node_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) related_node__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Related_node_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) related_node__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Related_node_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Request_TRANSPORTProperties
{
  PROP_REQUEST__T_R_A_N_S_P_O_R_T_0,
  PROP_REQUEST__T_R_A_N_S_P_O_R_T_OPERATION,
  PROP_REQUEST__T_R_A_N_S_P_O_R_T_HEADER,
  PROP_REQUEST__T_R_A_N_S_P_O_R_T_FIELDS_COUNT,
  PROP_REQUEST__T_R_A_N_S_P_O_R_T_FIELDS,
  PROP_REQUEST__T_R_A_N_S_P_O_R_T_RELS_COUNT,
  PROP_REQUEST__T_R_A_N_S_P_O_R_T_RELATED_NODES
};

/* reads a request__t_r_a_n_s_p_o_r_t object */
static gint32
request__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Request_TRANSPORT * this_object = REQUEST__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->operation = (Crud_operation_TRANSPORT)ecast7;
          this_object->__isset_operation = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->header), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_header = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->fields_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_fields_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Native_field_TRANSPORT * _elem8 = NULL;
              if ( _elem8 != NULL)
              {
                g_object_unref (_elem8);
              }
              _elem8 = g_object_new (TYPE_NATIVE_FIELD__T_R_A_N_S_P_O_R_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem8), protocol, error)) < 0)
              {
                g_object_unref (_elem8);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->fields, _elem8);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_fields = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->rels_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rels_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Related_node_TRANSPORT * _elem9 = NULL;
              if ( _elem9 != NULL)
              {
                g_object_unref (_elem9);
              }
              _elem9 = g_object_new (TYPE_RELATED_NODE__T_R_A_N_S_P_O_R_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem9), protocol, error)) < 0)
              {
                g_object_unref (_elem9);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->related_nodes, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_related_nodes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
request__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Request_TRANSPORT * this_object = REQUEST__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Request_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "operation", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->operation, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "header", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->header), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fields_count", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->fields_count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_fields == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fields", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i10;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->fields ? this_object->fields->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i10 = 0; i10 < (this_object->fields ? this_object->fields->len : 0); i10++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->fields, i10))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "rels_count", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->rels_count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_related_nodes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "related_nodes", T_LIST, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i11;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->related_nodes ? this_object->related_nodes->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i11 = 0; i11 < (this_object->related_nodes ? this_object->related_nodes->len : 0); i11++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->related_nodes, i11))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
request__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  Request_TRANSPORT *self = REQUEST__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_OPERATION:
      self->operation = g_value_get_int (value);
      self->__isset_operation = TRUE;
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_HEADER:
      if (self->header != NULL)
        g_object_unref (self->header);
      self->header = g_value_dup_object (value);
      self->__isset_header = TRUE;
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_FIELDS_COUNT:
      self->fields_count = g_value_get_int64 (value);
      self->__isset_fields_count = TRUE;
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_FIELDS:
      if (self->fields != NULL)
        g_ptr_array_unref (self->fields);
      self->fields = g_value_dup_boxed (value);
      self->__isset_fields = TRUE;
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_RELS_COUNT:
      self->rels_count = g_value_get_int64 (value);
      self->__isset_rels_count = TRUE;
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_RELATED_NODES:
      if (self->related_nodes != NULL)
        g_ptr_array_unref (self->related_nodes);
      self->related_nodes = g_value_dup_boxed (value);
      self->__isset_related_nodes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
request__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  Request_TRANSPORT *self = REQUEST__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_OPERATION:
      g_value_set_int (value, self->operation);
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_HEADER:
      g_value_set_object (value, self->header);
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_FIELDS_COUNT:
      g_value_set_int64 (value, self->fields_count);
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_FIELDS:
      g_value_set_boxed (value, self->fields);
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_RELS_COUNT:
      g_value_set_int64 (value, self->rels_count);
      break;

    case PROP_REQUEST__T_R_A_N_S_P_O_R_T_RELATED_NODES:
      g_value_set_boxed (value, self->related_nodes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
request__t_r_a_n_s_p_o_r_t_instance_init (Request_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_operation = FALSE;
  object->header = g_object_new (TYPE_HEADER__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_header = FALSE;
  object->fields_count = 0;
  object->__isset_fields_count = FALSE;
  object->fields = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_fields = FALSE;
  object->rels_count = 0;
  object->__isset_rels_count = FALSE;
  object->related_nodes = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_related_nodes = FALSE;
}

static void 
request__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Request_TRANSPORT *tobject = REQUEST__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->header != NULL)
  {
    g_object_unref(tobject->header);
    tobject->header = NULL;
  }
  if (tobject->fields != NULL)
  {
    g_ptr_array_unref (tobject->fields);
    tobject->fields = NULL;
  }
  if (tobject->related_nodes != NULL)
  {
    g_ptr_array_unref (tobject->related_nodes);
    tobject->related_nodes = NULL;
  }
}

static void
request__t_r_a_n_s_p_o_r_t_class_init (Request_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = request__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = request__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = request__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = request__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = request__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST__T_R_A_N_S_P_O_R_T_OPERATION,
     g_param_spec_int ("operation",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST__T_R_A_N_S_P_O_R_T_HEADER,
     g_param_spec_object ("header",
                         NULL,
                         NULL,
                         TYPE_HEADER__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST__T_R_A_N_S_P_O_R_T_FIELDS_COUNT,
     g_param_spec_int64 ("fields_count",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST__T_R_A_N_S_P_O_R_T_FIELDS,
     g_param_spec_boxed ("fields",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST__T_R_A_N_S_P_O_R_T_RELS_COUNT,
     g_param_spec_int64 ("rels_count",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST__T_R_A_N_S_P_O_R_T_RELATED_NODES,
     g_param_spec_boxed ("related_nodes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
request__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Request_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) request__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Request_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) request__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Request_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Node_TRANSPORTProperties
{
  PROP_NODE__T_R_A_N_S_P_O_R_T_0,
  PROP_NODE__T_R_A_N_S_P_O_R_T_TAG_NAME,
  PROP_NODE__T_R_A_N_S_P_O_R_T_FIELDS,
  PROP_NODE__T_R_A_N_S_P_O_R_T_RELATED_NODE_IDS
};

/* reads a node__t_r_a_n_s_p_o_r_t object */
static gint32
node__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Node_TRANSPORT * this_object = NODE__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tag_name != NULL)
          {
            g_free(this_object->tag_name);
            this_object->tag_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tag_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tag_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Native_field_TRANSPORT * _elem12 = NULL;
              if ( _elem12 != NULL)
              {
                g_object_unref (_elem12);
              }
              _elem12 = g_object_new (TYPE_NATIVE_FIELD__T_R_A_N_S_P_O_R_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem12), protocol, error)) < 0)
              {
                g_object_unref (_elem12);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->fields, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_fields = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Value_TRANSPORT * _elem13 = NULL;
              if ( _elem13 != NULL)
              {
                g_object_unref (_elem13);
              }
              _elem13 = g_object_new (TYPE_VALUE__T_R_A_N_S_P_O_R_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem13), protocol, error)) < 0)
              {
                g_object_unref (_elem13);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->related_node_ids, _elem13);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_related_node_ids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Node_TRANSPORT * this_object = NODE__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Node_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tag_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tag_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fields", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i14;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->fields ? this_object->fields->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i14 = 0; i14 < (this_object->fields ? this_object->fields->len : 0); i14++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->fields, i14))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "related_node_ids", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i15;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->related_node_ids ? this_object->related_node_ids->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i15 = 0; i15 < (this_object->related_node_ids ? this_object->related_node_ids->len : 0); i15++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->related_node_ids, i15))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  Node_TRANSPORT *self = NODE__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_NODE__T_R_A_N_S_P_O_R_T_TAG_NAME:
      if (self->tag_name != NULL)
        g_free (self->tag_name);
      self->tag_name = g_value_dup_string (value);
      self->__isset_tag_name = TRUE;
      break;

    case PROP_NODE__T_R_A_N_S_P_O_R_T_FIELDS:
      if (self->fields != NULL)
        g_ptr_array_unref (self->fields);
      self->fields = g_value_dup_boxed (value);
      self->__isset_fields = TRUE;
      break;

    case PROP_NODE__T_R_A_N_S_P_O_R_T_RELATED_NODE_IDS:
      if (self->related_node_ids != NULL)
        g_ptr_array_unref (self->related_node_ids);
      self->related_node_ids = g_value_dup_boxed (value);
      self->__isset_related_node_ids = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  Node_TRANSPORT *self = NODE__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_NODE__T_R_A_N_S_P_O_R_T_TAG_NAME:
      g_value_set_string (value, self->tag_name);
      break;

    case PROP_NODE__T_R_A_N_S_P_O_R_T_FIELDS:
      g_value_set_boxed (value, self->fields);
      break;

    case PROP_NODE__T_R_A_N_S_P_O_R_T_RELATED_NODE_IDS:
      g_value_set_boxed (value, self->related_node_ids);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node__t_r_a_n_s_p_o_r_t_instance_init (Node_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tag_name = NULL;
  object->__isset_tag_name = FALSE;
  object->fields = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_fields = FALSE;
  object->related_node_ids = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_related_node_ids = FALSE;
}

static void 
node__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Node_TRANSPORT *tobject = NODE__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tag_name != NULL)
  {
    g_free(tobject->tag_name);
    tobject->tag_name = NULL;
  }
  if (tobject->fields != NULL)
  {
    g_ptr_array_unref (tobject->fields);
    tobject->fields = NULL;
  }
  if (tobject->related_node_ids != NULL)
  {
    g_ptr_array_unref (tobject->related_node_ids);
    tobject->related_node_ids = NULL;
  }
}

static void
node__t_r_a_n_s_p_o_r_t_class_init (Node_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = node__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = node__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = node__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = node__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE__T_R_A_N_S_P_O_R_T_TAG_NAME,
     g_param_spec_string ("tag_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NODE__T_R_A_N_S_P_O_R_T_FIELDS,
     g_param_spec_boxed ("fields",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NODE__T_R_A_N_S_P_O_R_T_RELATED_NODE_IDS,
     g_param_spec_boxed ("related_node_ids",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
node__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Node_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Node_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) node__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Node_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

enum _Answer_TRANSPORTProperties
{
  PROP_ANSWER__T_R_A_N_S_P_O_R_T_0,
  PROP_ANSWER__T_R_A_N_S_P_O_R_T_CODE,
  PROP_ANSWER__T_R_A_N_S_P_O_R_T_ERROR_MESSAGE,
  PROP_ANSWER__T_R_A_N_S_P_O_R_T_NODES
};

/* reads a answer__t_r_a_n_s_p_o_r_t object */
static gint32
answer__t_r_a_n_s_p_o_r_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Answer_TRANSPORT * this_object = ANSWER__T_R_A_N_S_P_O_R_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->code, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->error_message != NULL)
          {
            g_free(this_object->error_message);
            this_object->error_message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->error_message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_error_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Node_TRANSPORT * _elem16 = NULL;
              if ( _elem16 != NULL)
              {
                g_object_unref (_elem16);
              }
              _elem16 = g_object_new (TYPE_NODE__T_R_A_N_S_P_O_R_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem16), protocol, error)) < 0)
              {
                g_object_unref (_elem16);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->nodes, _elem16);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_nodes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
answer__t_r_a_n_s_p_o_r_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Answer_TRANSPORT * this_object = ANSWER__T_R_A_N_S_P_O_R_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Answer_TRANSPORT", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->code, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "error_message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->error_message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nodes", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i17;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->nodes ? this_object->nodes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i17 = 0; i17 < (this_object->nodes ? this_object->nodes->len : 0); i17++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->nodes, i17))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
answer__t_r_a_n_s_p_o_r_t_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  Answer_TRANSPORT *self = ANSWER__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_ANSWER__T_R_A_N_S_P_O_R_T_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_ANSWER__T_R_A_N_S_P_O_R_T_ERROR_MESSAGE:
      if (self->error_message != NULL)
        g_free (self->error_message);
      self->error_message = g_value_dup_string (value);
      self->__isset_error_message = TRUE;
      break;

    case PROP_ANSWER__T_R_A_N_S_P_O_R_T_NODES:
      if (self->nodes != NULL)
        g_ptr_array_unref (self->nodes);
      self->nodes = g_value_dup_boxed (value);
      self->__isset_nodes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
answer__t_r_a_n_s_p_o_r_t_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  Answer_TRANSPORT *self = ANSWER__T_R_A_N_S_P_O_R_T (object);

  switch (property_id)
  {
    case PROP_ANSWER__T_R_A_N_S_P_O_R_T_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_ANSWER__T_R_A_N_S_P_O_R_T_ERROR_MESSAGE:
      g_value_set_string (value, self->error_message);
      break;

    case PROP_ANSWER__T_R_A_N_S_P_O_R_T_NODES:
      g_value_set_boxed (value, self->nodes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
answer__t_r_a_n_s_p_o_r_t_instance_init (Answer_TRANSPORT * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->code = 0;
  object->__isset_code = FALSE;
  object->error_message = NULL;
  object->__isset_error_message = FALSE;
  object->nodes = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_nodes = FALSE;
}

static void 
answer__t_r_a_n_s_p_o_r_t_finalize (GObject *object)
{
  Answer_TRANSPORT *tobject = ANSWER__T_R_A_N_S_P_O_R_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->error_message != NULL)
  {
    g_free(tobject->error_message);
    tobject->error_message = NULL;
  }
  if (tobject->nodes != NULL)
  {
    g_ptr_array_unref (tobject->nodes);
    tobject->nodes = NULL;
  }
}

static void
answer__t_r_a_n_s_p_o_r_t_class_init (Answer_TRANSPORTClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = answer__t_r_a_n_s_p_o_r_t_read;
  struct_class->write = answer__t_r_a_n_s_p_o_r_t_write;

  gobject_class->finalize = answer__t_r_a_n_s_p_o_r_t_finalize;
  gobject_class->get_property = answer__t_r_a_n_s_p_o_r_t_get_property;
  gobject_class->set_property = answer__t_r_a_n_s_p_o_r_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ANSWER__T_R_A_N_S_P_O_R_T_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ANSWER__T_R_A_N_S_P_O_R_T_ERROR_MESSAGE,
     g_param_spec_string ("error_message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ANSWER__T_R_A_N_S_P_O_R_T_NODES,
     g_param_spec_boxed ("nodes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
answer__t_r_a_n_s_p_o_r_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Answer_TRANSPORTClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) answer__t_r_a_n_s_p_o_r_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Answer_TRANSPORT),
      0, /* n_preallocs */
      (GInstanceInitFunc) answer__t_r_a_n_s_p_o_r_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Answer_TRANSPORTType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

/* reads a d_b_request_ping_args object */
static gint32
d_b_request_ping_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DBRequestPingArgs * this_object = D_B_REQUEST_PING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
d_b_request_ping_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DBRequestPingArgs * this_object = D_B_REQUEST_PING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DBRequestPingArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
d_b_request_ping_args_instance_init (DBRequestPingArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
d_b_request_ping_args_finalize (GObject *object)
{
  DBRequestPingArgs *tobject = D_B_REQUEST_PING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
d_b_request_ping_args_class_init (DBRequestPingArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = d_b_request_ping_args_read;
  struct_class->write = d_b_request_ping_args_write;

  gobject_class->finalize = d_b_request_ping_args_finalize;
}

GType
d_b_request_ping_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DBRequestPingArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) d_b_request_ping_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DBRequestPingArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) d_b_request_ping_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DBRequestPingArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a d_b_request_ping_result object */
static gint32
d_b_request_ping_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DBRequestPingResult * this_object = D_B_REQUEST_PING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
d_b_request_ping_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DBRequestPingResult * this_object = D_B_REQUEST_PING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DBRequestPingResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
d_b_request_ping_result_instance_init (DBRequestPingResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
d_b_request_ping_result_finalize (GObject *object)
{
  DBRequestPingResult *tobject = D_B_REQUEST_PING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
d_b_request_ping_result_class_init (DBRequestPingResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = d_b_request_ping_result_read;
  struct_class->write = d_b_request_ping_result_write;

  gobject_class->finalize = d_b_request_ping_result_finalize;
}

GType
d_b_request_ping_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DBRequestPingResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) d_b_request_ping_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DBRequestPingResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) d_b_request_ping_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DBRequestPingResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DBRequestDoRequestArgsProperties
{
  PROP_D_B_REQUEST_DO_REQUEST_ARGS_0,
  PROP_D_B_REQUEST_DO_REQUEST_ARGS_REQ
};

/* reads a d_b_request_do_request_args object */
static gint32
d_b_request_do_request_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DBRequestDoRequestArgs * this_object = D_B_REQUEST_DO_REQUEST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->req), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_req = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
d_b_request_do_request_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DBRequestDoRequestArgs * this_object = D_B_REQUEST_DO_REQUEST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DBRequestDoRequestArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "req", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->req), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
d_b_request_do_request_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  DBRequestDoRequestArgs *self = D_B_REQUEST_DO_REQUEST_ARGS (object);

  switch (property_id)
  {
    case PROP_D_B_REQUEST_DO_REQUEST_ARGS_REQ:
      if (self->req != NULL)
        g_object_unref (self->req);
      self->req = g_value_dup_object (value);
      self->__isset_req = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
d_b_request_do_request_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  DBRequestDoRequestArgs *self = D_B_REQUEST_DO_REQUEST_ARGS (object);

  switch (property_id)
  {
    case PROP_D_B_REQUEST_DO_REQUEST_ARGS_REQ:
      g_value_set_object (value, self->req);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
d_b_request_do_request_args_instance_init (DBRequestDoRequestArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->req = g_object_new (TYPE_REQUEST__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_req = FALSE;
}

static void 
d_b_request_do_request_args_finalize (GObject *object)
{
  DBRequestDoRequestArgs *tobject = D_B_REQUEST_DO_REQUEST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->req != NULL)
  {
    g_object_unref(tobject->req);
    tobject->req = NULL;
  }
}

static void
d_b_request_do_request_args_class_init (DBRequestDoRequestArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = d_b_request_do_request_args_read;
  struct_class->write = d_b_request_do_request_args_write;

  gobject_class->finalize = d_b_request_do_request_args_finalize;
  gobject_class->get_property = d_b_request_do_request_args_get_property;
  gobject_class->set_property = d_b_request_do_request_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_D_B_REQUEST_DO_REQUEST_ARGS_REQ,
     g_param_spec_object ("req",
                         NULL,
                         NULL,
                         TYPE_REQUEST__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));
}

GType
d_b_request_do_request_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DBRequestDoRequestArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) d_b_request_do_request_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DBRequestDoRequestArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) d_b_request_do_request_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DBRequestDoRequestArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DBRequestDoRequestResultProperties
{
  PROP_D_B_REQUEST_DO_REQUEST_RESULT_0,
  PROP_D_B_REQUEST_DO_REQUEST_RESULT_SUCCESS
};

/* reads a d_b_request_do_request_result object */
static gint32
d_b_request_do_request_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DBRequestDoRequestResult * this_object = D_B_REQUEST_DO_REQUEST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
d_b_request_do_request_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DBRequestDoRequestResult * this_object = D_B_REQUEST_DO_REQUEST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DBRequestDoRequestResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
d_b_request_do_request_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  DBRequestDoRequestResult *self = D_B_REQUEST_DO_REQUEST_RESULT (object);

  switch (property_id)
  {
    case PROP_D_B_REQUEST_DO_REQUEST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
d_b_request_do_request_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  DBRequestDoRequestResult *self = D_B_REQUEST_DO_REQUEST_RESULT (object);

  switch (property_id)
  {
    case PROP_D_B_REQUEST_DO_REQUEST_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
d_b_request_do_request_result_instance_init (DBRequestDoRequestResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_ANSWER__T_R_A_N_S_P_O_R_T, NULL);
  object->__isset_success = FALSE;
}

static void 
d_b_request_do_request_result_finalize (GObject *object)
{
  DBRequestDoRequestResult *tobject = D_B_REQUEST_DO_REQUEST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
d_b_request_do_request_result_class_init (DBRequestDoRequestResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = d_b_request_do_request_result_read;
  struct_class->write = d_b_request_do_request_result_write;

  gobject_class->finalize = d_b_request_do_request_result_finalize;
  gobject_class->get_property = d_b_request_do_request_result_get_property;
  gobject_class->set_property = d_b_request_do_request_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_D_B_REQUEST_DO_REQUEST_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_ANSWER__T_R_A_N_S_P_O_R_T,
                         G_PARAM_READWRITE));
}

GType
d_b_request_do_request_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DBRequestDoRequestResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) d_b_request_do_request_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DBRequestDoRequestResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) d_b_request_do_request_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DBRequestDoRequestResultType",
                                   &type_info, 0);
  }

  return type;
}

