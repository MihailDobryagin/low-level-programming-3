/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "schema_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_Crud_operation(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case CRUD_OPERATION_CRUD_GET:return "CRUD_OPERATION_CRUD_GET";
  case CRUD_OPERATION_CRUD_REMOVE:return "CRUD_OPERATION_CRUD_REMOVE";
  case CRUD_OPERATION_CRUD_NEW:return "CRUD_OPERATION_CRUD_NEW";
  case CRUD_OPERATION_CRUD_UPDATE:return "CRUD_OPERATION_CRUD_UPDATE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Condition_code(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case CONDITION_CODE_OP_EQUAL:return "CONDITION_CODE_OP_EQUAL";
  case CONDITION_CODE_OP_GREATER:return "CONDITION_CODE_OP_GREATER";
  case CONDITION_CODE_OP_LESS:return "CONDITION_CODE_OP_LESS";
  case CONDITION_CODE_OP_NOT_GREATER:return "CONDITION_CODE_OP_NOT_GREATER";
  case CONDITION_CODE_OP_NOT_LESS:return "CONDITION_CODE_OP_NOT_LESS";
  case CONDITION_CODE_OP_SUBSTR:return "CONDITION_CODE_OP_SUBSTR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Type(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case TYPE_STRING_TYPE:return "TYPE_STRING_TYPE";
  case TYPE_INTEGER_TYPE:return "TYPE_INTEGER_TYPE";
  case TYPE_BOOLEAN_TYPE:return "TYPE_BOOLEAN_TYPE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _ValueProperties
{
  PROP_VALUE_0,
  PROP_VALUE_INTEGER,
  PROP_VALUE_BOOLEAN,
  PROP_VALUE_STRING
};

/* reads a value object */
static gint32
value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Value * this_object = VALUE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->Integer, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_Integer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->Boolean, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_Boolean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->String != NULL)
          {
            g_free(this_object->String);
            this_object->String = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->String, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_String = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Value * this_object = VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Value", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_Integer == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "Integer", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->Integer, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_Boolean == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "Boolean", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->Boolean, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_String == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "String", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->String, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
value_set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  Value *self = VALUE (object);

  switch (property_id)
  {
    case PROP_VALUE_INTEGER:
      self->Integer = g_value_get_int (value);
      self->__isset_Integer = TRUE;
      break;

    case PROP_VALUE_BOOLEAN:
      self->Boolean = g_value_get_boolean (value);
      self->__isset_Boolean = TRUE;
      break;

    case PROP_VALUE_STRING:
      if (self->String != NULL)
        g_free (self->String);
      self->String = g_value_dup_string (value);
      self->__isset_String = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
value_get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  Value *self = VALUE (object);

  switch (property_id)
  {
    case PROP_VALUE_INTEGER:
      g_value_set_int (value, self->Integer);
      break;

    case PROP_VALUE_BOOLEAN:
      g_value_set_boolean (value, self->Boolean);
      break;

    case PROP_VALUE_STRING:
      g_value_set_string (value, self->String);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
value_instance_init (Value * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->Integer = 0;
  object->__isset_Integer = FALSE;
  object->Boolean = 0;
  object->__isset_Boolean = FALSE;
  object->String = NULL;
  object->__isset_String = FALSE;
}

static void 
value_finalize (GObject *object)
{
  Value *tobject = VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->String != NULL)
  {
    g_free(tobject->String);
    tobject->String = NULL;
  }
}

static void
value_class_init (ValueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = value_read;
  struct_class->write = value_write;

  gobject_class->finalize = value_finalize;
  gobject_class->get_property = value_get_property;
  gobject_class->set_property = value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE_INTEGER,
     g_param_spec_int ("Integer",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE_BOOLEAN,
     g_param_spec_boolean ("Boolean",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_VALUE_STRING,
     g_param_spec_string ("String",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ValueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Value),
      0, /* n_preallocs */
      (GInstanceInitFunc) value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ValueType",
                                   &type_info, 0);
  }

  return type;
}

enum _Field_valueProperties
{
  PROP_FIELD_VALUE_0,
  PROP_FIELD_VALUE_TYPE,
  PROP_FIELD_VALUE_VALUE
};

/* reads a field_value object */
static gint32
field_value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Field_value * this_object = FIELD_VALUE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (Type)ecast0;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
field_value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Field_value * this_object = FIELD_VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Field_value", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
field_value_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  Field_value *self = FIELD_VALUE (object);

  switch (property_id)
  {
    case PROP_FIELD_VALUE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_FIELD_VALUE_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
field_value_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  Field_value *self = FIELD_VALUE (object);

  switch (property_id)
  {
    case PROP_FIELD_VALUE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_FIELD_VALUE_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
field_value_instance_init (Field_value * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->value = g_object_new (TYPE_VALUE, NULL);
  object->__isset_value = FALSE;
}

static void 
field_value_finalize (GObject *object)
{
  Field_value *tobject = FIELD_VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
field_value_class_init (Field_valueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = field_value_read;
  struct_class->write = field_value_write;

  gobject_class->finalize = field_value_finalize;
  gobject_class->get_property = field_value_get_property;
  gobject_class->set_property = field_value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FIELD_VALUE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FIELD_VALUE_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_VALUE,
                         G_PARAM_READWRITE));
}

GType
field_value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Field_valueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) field_value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Field_value),
      0, /* n_preallocs */
      (GInstanceInitFunc) field_value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Field_valueType",
                                   &type_info, 0);
  }

  return type;
}

enum _FieldProperties
{
  PROP_FIELD_0,
  PROP_FIELD_NAME,
  PROP_FIELD_VALUE
};

/* reads a field object */
static gint32
field_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Field * this_object = FIELD(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
field_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Field * this_object = FIELD(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Field", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
field_set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  Field *self = FIELD (object);

  switch (property_id)
  {
    case PROP_FIELD_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_FIELD_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
field_get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  Field *self = FIELD (object);

  switch (property_id)
  {
    case PROP_FIELD_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_FIELD_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
field_instance_init (Field * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->value = g_object_new (TYPE_FIELD_VALUE, NULL);
  object->__isset_value = FALSE;
}

static void 
field_finalize (GObject *object)
{
  Field *tobject = FIELD (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
field_class_init (FieldClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = field_read;
  struct_class->write = field_write;

  gobject_class->finalize = field_finalize;
  gobject_class->get_property = field_get_property;
  gobject_class->set_property = field_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FIELD_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FIELD_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_FIELD_VALUE,
                         G_PARAM_READWRITE));
}

GType
field_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FieldClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) field_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Field),
      0, /* n_preallocs */
      (GInstanceInitFunc) field_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FieldType",
                                   &type_info, 0);
  }

  return type;
}

enum _EntityProperties
{
  PROP_ENTITY_0,
  PROP_ENTITY_FIELDS_COUNT,
  PROP_ENTITY_REL_COUNT,
  PROP_ENTITY_FIELDS,
  PROP_ENTITY_REL_IDS
};

/* reads a entity object */
static gint32
entity_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Entity * this_object = ENTITY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->fields_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_fields_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->rel_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rel_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Field * _elem1 = NULL;
              if ( _elem1 != NULL)
              {
                g_object_unref (_elem1);
              }
              _elem1 = g_object_new (TYPE_FIELD, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1), protocol, error)) < 0)
              {
                g_object_unref (_elem1);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->fields, _elem1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_fields = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Field_value * _elem2 = NULL;
              if ( _elem2 != NULL)
              {
                g_object_unref (_elem2);
              }
              _elem2 = g_object_new (TYPE_FIELD_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem2), protocol, error)) < 0)
              {
                g_object_unref (_elem2);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->rel_ids, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rel_ids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
entity_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Entity * this_object = ENTITY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Entity", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fields_count", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->fields_count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rel_count", T_I16, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->rel_count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fields", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->fields ? this_object->fields->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < (this_object->fields ? this_object->fields->len : 0); i3++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->fields, i3))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rel_ids", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i4;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->rel_ids ? this_object->rel_ids->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i4 = 0; i4 < (this_object->rel_ids ? this_object->rel_ids->len : 0); i4++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->rel_ids, i4))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
entity_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  Entity *self = ENTITY (object);

  switch (property_id)
  {
    case PROP_ENTITY_FIELDS_COUNT:
      self->fields_count = g_value_get_int (value);
      self->__isset_fields_count = TRUE;
      break;

    case PROP_ENTITY_REL_COUNT:
      self->rel_count = g_value_get_int (value);
      self->__isset_rel_count = TRUE;
      break;

    case PROP_ENTITY_FIELDS:
      if (self->fields != NULL)
        g_ptr_array_unref (self->fields);
      self->fields = g_value_dup_boxed (value);
      self->__isset_fields = TRUE;
      break;

    case PROP_ENTITY_REL_IDS:
      if (self->rel_ids != NULL)
        g_ptr_array_unref (self->rel_ids);
      self->rel_ids = g_value_dup_boxed (value);
      self->__isset_rel_ids = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
entity_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  Entity *self = ENTITY (object);

  switch (property_id)
  {
    case PROP_ENTITY_FIELDS_COUNT:
      g_value_set_int (value, self->fields_count);
      break;

    case PROP_ENTITY_REL_COUNT:
      g_value_set_int (value, self->rel_count);
      break;

    case PROP_ENTITY_FIELDS:
      g_value_set_boxed (value, self->fields);
      break;

    case PROP_ENTITY_REL_IDS:
      g_value_set_boxed (value, self->rel_ids);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
entity_instance_init (Entity * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->fields_count = 0;
  object->__isset_fields_count = FALSE;
  object->rel_count = 0;
  object->__isset_rel_count = FALSE;
  object->fields = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_fields = FALSE;
  object->rel_ids = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_rel_ids = FALSE;
}

static void 
entity_finalize (GObject *object)
{
  Entity *tobject = ENTITY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->fields != NULL)
  {
    g_ptr_array_unref (tobject->fields);
    tobject->fields = NULL;
  }
  if (tobject->rel_ids != NULL)
  {
    g_ptr_array_unref (tobject->rel_ids);
    tobject->rel_ids = NULL;
  }
}

static void
entity_class_init (EntityClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = entity_read;
  struct_class->write = entity_write;

  gobject_class->finalize = entity_finalize;
  gobject_class->get_property = entity_get_property;
  gobject_class->set_property = entity_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ENTITY_FIELDS_COUNT,
     g_param_spec_int ("fields_count",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ENTITY_REL_COUNT,
     g_param_spec_int ("rel_count",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ENTITY_FIELDS,
     g_param_spec_boxed ("fields",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ENTITY_REL_IDS,
     g_param_spec_boxed ("rel_ids",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
entity_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EntityClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) entity_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Entity),
      0, /* n_preallocs */
      (GInstanceInitFunc) entity_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EntityType",
                                   &type_info, 0);
  }

  return type;
}

enum _Field_filterProperties
{
  PROP_FIELD_FILTER_0,
  PROP_FIELD_FILTER_OP,
  PROP_FIELD_FILTER_FIELD_NAME,
  PROP_FIELD_FILTER_FIELD_VALUE
};

/* reads a field_filter object */
static gint32
field_filter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Field_filter * this_object = FIELD_FILTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast5;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (Condition_code)ecast5;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->field_name != NULL)
          {
            g_free(this_object->field_name);
            this_object->field_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->field_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->field_value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_field_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
field_filter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Field_filter * this_object = FIELD_FILTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Field_filter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field_name", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->field_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field_value", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->field_value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
field_filter_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  Field_filter *self = FIELD_FILTER (object);

  switch (property_id)
  {
    case PROP_FIELD_FILTER_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_FIELD_FILTER_FIELD_NAME:
      if (self->field_name != NULL)
        g_free (self->field_name);
      self->field_name = g_value_dup_string (value);
      self->__isset_field_name = TRUE;
      break;

    case PROP_FIELD_FILTER_FIELD_VALUE:
      if (self->field_value != NULL)
        g_object_unref (self->field_value);
      self->field_value = g_value_dup_object (value);
      self->__isset_field_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
field_filter_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  Field_filter *self = FIELD_FILTER (object);

  switch (property_id)
  {
    case PROP_FIELD_FILTER_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_FIELD_FILTER_FIELD_NAME:
      g_value_set_string (value, self->field_name);
      break;

    case PROP_FIELD_FILTER_FIELD_VALUE:
      g_value_set_object (value, self->field_value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
field_filter_instance_init (Field_filter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_op = FALSE;
  object->field_name = NULL;
  object->__isset_field_name = FALSE;
  object->field_value = g_object_new (TYPE_FIELD_VALUE, NULL);
  object->__isset_field_value = FALSE;
}

static void 
field_filter_finalize (GObject *object)
{
  Field_filter *tobject = FIELD_FILTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field_name != NULL)
  {
    g_free(tobject->field_name);
    tobject->field_name = NULL;
  }
  if (tobject->field_value != NULL)
  {
    g_object_unref(tobject->field_value);
    tobject->field_value = NULL;
  }
}

static void
field_filter_class_init (Field_filterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = field_filter_read;
  struct_class->write = field_filter_write;

  gobject_class->finalize = field_filter_finalize;
  gobject_class->get_property = field_filter_get_property;
  gobject_class->set_property = field_filter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FIELD_FILTER_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       5,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FIELD_FILTER_FIELD_NAME,
     g_param_spec_string ("field_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FIELD_FILTER_FIELD_VALUE,
     g_param_spec_object ("field_value",
                         NULL,
                         NULL,
                         TYPE_FIELD_VALUE,
                         G_PARAM_READWRITE));
}

GType
field_filter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Field_filterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) field_filter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Field_filter),
      0, /* n_preallocs */
      (GInstanceInitFunc) field_filter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Field_filterType",
                                   &type_info, 0);
  }

  return type;
}

enum _Condition_unionProperties
{
  PROP_CONDITION_UNION_0,
  PROP_CONDITION_UNION_ID,
  PROP_CONDITION_UNION_FIELD_FILTER
};

/* reads a condition_union object */
static gint32
condition_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Condition_union * this_object = CONDITION_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->id), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->field_filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_field_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
condition_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Condition_union * this_object = CONDITION_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Condition_union", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->id), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field_filter == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field_filter", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->field_filter), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
condition_union_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  Condition_union *self = CONDITION_UNION (object);

  switch (property_id)
  {
    case PROP_CONDITION_UNION_ID:
      if (self->id != NULL)
        g_object_unref (self->id);
      self->id = g_value_dup_object (value);
      self->__isset_id = TRUE;
      break;

    case PROP_CONDITION_UNION_FIELD_FILTER:
      if (self->field_filter != NULL)
        g_object_unref (self->field_filter);
      self->field_filter = g_value_dup_object (value);
      self->__isset_field_filter = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
condition_union_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  Condition_union *self = CONDITION_UNION (object);

  switch (property_id)
  {
    case PROP_CONDITION_UNION_ID:
      g_value_set_object (value, self->id);
      break;

    case PROP_CONDITION_UNION_FIELD_FILTER:
      g_value_set_object (value, self->field_filter);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
condition_union_instance_init (Condition_union * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = g_object_new (TYPE_FIELD_VALUE, NULL);
  object->__isset_id = FALSE;
  object->field_filter = g_object_new (TYPE_FIELD_FILTER, NULL);
  object->__isset_field_filter = FALSE;
}

static void 
condition_union_finalize (GObject *object)
{
  Condition_union *tobject = CONDITION_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->id != NULL)
  {
    g_object_unref(tobject->id);
    tobject->id = NULL;
  }
  if (tobject->field_filter != NULL)
  {
    g_object_unref(tobject->field_filter);
    tobject->field_filter = NULL;
  }
}

static void
condition_union_class_init (Condition_unionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = condition_union_read;
  struct_class->write = condition_union_write;

  gobject_class->finalize = condition_union_finalize;
  gobject_class->get_property = condition_union_get_property;
  gobject_class->set_property = condition_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION_UNION_ID,
     g_param_spec_object ("id",
                         NULL,
                         NULL,
                         TYPE_FIELD_VALUE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION_UNION_FIELD_FILTER,
     g_param_spec_object ("field_filter",
                         NULL,
                         NULL,
                         TYPE_FIELD_FILTER,
                         G_PARAM_READWRITE));
}

GType
condition_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Condition_unionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) condition_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Condition_union),
      0, /* n_preallocs */
      (GInstanceInitFunc) condition_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Condition_unionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ConditionProperties
{
  PROP_CONDITION_0,
  PROP_CONDITION_IS_NEGATIVE,
  PROP_CONDITION_IS_ID,
  PROP_CONDITION_CONDITION_UNION
};

/* reads a condition object */
static gint32
condition_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Condition * this_object = CONDITION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->is_negative, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_negative = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->is_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->condition_union), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_condition_union = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
condition_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Condition * this_object = CONDITION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Condition", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_negative", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->is_negative, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_id", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->is_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "condition_union", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->condition_union), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
condition_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  Condition *self = CONDITION (object);

  switch (property_id)
  {
    case PROP_CONDITION_IS_NEGATIVE:
      self->is_negative = g_value_get_int (value);
      self->__isset_is_negative = TRUE;
      break;

    case PROP_CONDITION_IS_ID:
      self->is_id = g_value_get_int (value);
      self->__isset_is_id = TRUE;
      break;

    case PROP_CONDITION_CONDITION_UNION:
      if (self->condition_union != NULL)
        g_object_unref (self->condition_union);
      self->condition_union = g_value_dup_object (value);
      self->__isset_condition_union = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
condition_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  Condition *self = CONDITION (object);

  switch (property_id)
  {
    case PROP_CONDITION_IS_NEGATIVE:
      g_value_set_int (value, self->is_negative);
      break;

    case PROP_CONDITION_IS_ID:
      g_value_set_int (value, self->is_id);
      break;

    case PROP_CONDITION_CONDITION_UNION:
      g_value_set_object (value, self->condition_union);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
condition_instance_init (Condition * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_negative = 0;
  object->__isset_is_negative = FALSE;
  object->is_id = 0;
  object->__isset_is_id = FALSE;
  object->condition_union = g_object_new (TYPE_CONDITION_UNION, NULL);
  object->__isset_condition_union = FALSE;
}

static void 
condition_finalize (GObject *object)
{
  Condition *tobject = CONDITION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->condition_union != NULL)
  {
    g_object_unref(tobject->condition_union);
    tobject->condition_union = NULL;
  }
}

static void
condition_class_init (ConditionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = condition_read;
  struct_class->write = condition_write;

  gobject_class->finalize = condition_finalize;
  gobject_class->get_property = condition_get_property;
  gobject_class->set_property = condition_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION_IS_NEGATIVE,
     g_param_spec_int ("is_negative",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION_IS_ID,
     g_param_spec_int ("is_id",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION_CONDITION_UNION,
     g_param_spec_object ("condition_union",
                         NULL,
                         NULL,
                         TYPE_CONDITION_UNION,
                         G_PARAM_READWRITE));
}

GType
condition_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ConditionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) condition_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Condition),
      0, /* n_preallocs */
      (GInstanceInitFunc) condition_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ConditionType",
                                   &type_info, 0);
  }

  return type;
}

enum _Filter_listProperties
{
  PROP_FILTER_LIST_0,
  PROP_FILTER_LIST_IS_NEGATIVE,
  PROP_FILTER_LIST_AND_CONDITIONS
};

/* reads a filter_list object */
static gint32
filter_list_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Filter_list * this_object = FILTER_LIST(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->is_negative, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_negative = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Condition * _elem6 = NULL;
              if ( _elem6 != NULL)
              {
                g_object_unref (_elem6);
              }
              _elem6 = g_object_new (TYPE_CONDITION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem6), protocol, error)) < 0)
              {
                g_object_unref (_elem6);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->and_conditions, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_and_conditions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
filter_list_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Filter_list * this_object = FILTER_LIST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Filter_list", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "is_negative", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->is_negative, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "and_conditions", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i7;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->and_conditions ? this_object->and_conditions->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i7 = 0; i7 < (this_object->and_conditions ? this_object->and_conditions->len : 0); i7++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->and_conditions, i7))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
filter_list_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  Filter_list *self = FILTER_LIST (object);

  switch (property_id)
  {
    case PROP_FILTER_LIST_IS_NEGATIVE:
      self->is_negative = g_value_get_int (value);
      self->__isset_is_negative = TRUE;
      break;

    case PROP_FILTER_LIST_AND_CONDITIONS:
      if (self->and_conditions != NULL)
        g_ptr_array_unref (self->and_conditions);
      self->and_conditions = g_value_dup_boxed (value);
      self->__isset_and_conditions = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
filter_list_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  Filter_list *self = FILTER_LIST (object);

  switch (property_id)
  {
    case PROP_FILTER_LIST_IS_NEGATIVE:
      g_value_set_int (value, self->is_negative);
      break;

    case PROP_FILTER_LIST_AND_CONDITIONS:
      g_value_set_boxed (value, self->and_conditions);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
filter_list_instance_init (Filter_list * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->is_negative = 0;
  object->__isset_is_negative = FALSE;
  object->and_conditions = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_and_conditions = FALSE;
}

static void 
filter_list_finalize (GObject *object)
{
  Filter_list *tobject = FILTER_LIST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->and_conditions != NULL)
  {
    g_ptr_array_unref (tobject->and_conditions);
    tobject->and_conditions = NULL;
  }
}

static void
filter_list_class_init (Filter_listClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = filter_list_read;
  struct_class->write = filter_list_write;

  gobject_class->finalize = filter_list_finalize;
  gobject_class->get_property = filter_list_get_property;
  gobject_class->set_property = filter_list_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FILTER_LIST_IS_NEGATIVE,
     g_param_spec_int ("is_negative",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILTER_LIST_AND_CONDITIONS,
     g_param_spec_boxed ("and_conditions",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
filter_list_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Filter_listClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) filter_list_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Filter_list),
      0, /* n_preallocs */
      (GInstanceInitFunc) filter_list_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Filter_listType",
                                   &type_info, 0);
  }

  return type;
}

enum _RequestProperties
{
  PROP_REQUEST_0,
  PROP_REQUEST_OP,
  PROP_REQUEST_FIELD_NAMES_TO_OUTPUT,
  PROP_REQUEST_TREE,
  PROP_REQUEST_ENTITY
};

/* reads a request object */
static gint32
request_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Request * this_object = REQUEST(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (Crud_operation)ecast8;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem9 = NULL;
              if (_elem9 != NULL)
              {
                g_free(_elem9);
                _elem9 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem9, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->field_names_to_output, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_field_names_to_output = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Filter_list * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_FILTER_LIST, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->tree, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_tree = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->entity), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_entity = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
request_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Request * this_object = REQUEST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Request", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field_names_to_output", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i11;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->field_names_to_output ? this_object->field_names_to_output->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i11 = 0; i11 < (this_object->field_names_to_output ? this_object->field_names_to_output->len : 0); i11++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->field_names_to_output, i11)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tree", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i12;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->tree ? this_object->tree->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i12 = 0; i12 < (this_object->tree ? this_object->tree->len : 0); i12++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->tree, i12))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "entity", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->entity), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
request_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  Request *self = REQUEST (object);

  switch (property_id)
  {
    case PROP_REQUEST_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_REQUEST_FIELD_NAMES_TO_OUTPUT:
      if (self->field_names_to_output != NULL)
        g_ptr_array_unref (self->field_names_to_output);
      self->field_names_to_output = g_value_dup_boxed (value);
      self->__isset_field_names_to_output = TRUE;
      break;

    case PROP_REQUEST_TREE:
      if (self->tree != NULL)
        g_ptr_array_unref (self->tree);
      self->tree = g_value_dup_boxed (value);
      self->__isset_tree = TRUE;
      break;

    case PROP_REQUEST_ENTITY:
      if (self->entity != NULL)
        g_object_unref (self->entity);
      self->entity = g_value_dup_object (value);
      self->__isset_entity = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
request_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  Request *self = REQUEST (object);

  switch (property_id)
  {
    case PROP_REQUEST_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_REQUEST_FIELD_NAMES_TO_OUTPUT:
      g_value_set_boxed (value, self->field_names_to_output);
      break;

    case PROP_REQUEST_TREE:
      g_value_set_boxed (value, self->tree);
      break;

    case PROP_REQUEST_ENTITY:
      g_value_set_object (value, self->entity);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
request_instance_init (Request * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_op = FALSE;
  object->field_names_to_output = g_ptr_array_new_with_free_func (g_free);
  object->__isset_field_names_to_output = FALSE;
  object->tree = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_tree = FALSE;
  object->entity = g_object_new (TYPE_ENTITY, NULL);
  object->__isset_entity = FALSE;
}

static void 
request_finalize (GObject *object)
{
  Request *tobject = REQUEST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->field_names_to_output != NULL)
  {
    g_ptr_array_unref (tobject->field_names_to_output);
    tobject->field_names_to_output = NULL;
  }
  if (tobject->tree != NULL)
  {
    g_ptr_array_unref (tobject->tree);
    tobject->tree = NULL;
  }
  if (tobject->entity != NULL)
  {
    g_object_unref(tobject->entity);
    tobject->entity = NULL;
  }
}

static void
request_class_init (RequestClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = request_read;
  struct_class->write = request_write;

  gobject_class->finalize = request_finalize;
  gobject_class->get_property = request_get_property;
  gobject_class->set_property = request_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST_FIELD_NAMES_TO_OUTPUT,
     g_param_spec_boxed ("field_names_to_output",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST_TREE,
     g_param_spec_boxed ("tree",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST_ENTITY,
     g_param_spec_object ("entity",
                         NULL,
                         NULL,
                         TYPE_ENTITY,
                         G_PARAM_READWRITE));
}

GType
request_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RequestClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) request_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Request),
      0, /* n_preallocs */
      (GInstanceInitFunc) request_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RequestType",
                                   &type_info, 0);
  }

  return type;
}

enum _AnswerProperties
{
  PROP_ANSWER_0,
  PROP_ANSWER_CODE,
  PROP_ANSWER_ERROR_MESSAGE,
  PROP_ANSWER_ENTITIES
};

/* reads a answer object */
static gint32
answer_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Answer * this_object = ANSWER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->code, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->error_message != NULL)
          {
            g_free(this_object->error_message);
            this_object->error_message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->error_message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_error_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Entity * _elem13 = NULL;
              if ( _elem13 != NULL)
              {
                g_object_unref (_elem13);
              }
              _elem13 = g_object_new (TYPE_ENTITY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem13), protocol, error)) < 0)
              {
                g_object_unref (_elem13);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->entities, _elem13);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_entities = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
answer_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Answer * this_object = ANSWER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Answer", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->code, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "error_message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->error_message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_entities == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "entities", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i14;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->entities ? this_object->entities->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i14 = 0; i14 < (this_object->entities ? this_object->entities->len : 0); i14++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->entities, i14))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
answer_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  Answer *self = ANSWER (object);

  switch (property_id)
  {
    case PROP_ANSWER_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_ANSWER_ERROR_MESSAGE:
      if (self->error_message != NULL)
        g_free (self->error_message);
      self->error_message = g_value_dup_string (value);
      self->__isset_error_message = TRUE;
      break;

    case PROP_ANSWER_ENTITIES:
      if (self->entities != NULL)
        g_ptr_array_unref (self->entities);
      self->entities = g_value_dup_boxed (value);
      self->__isset_entities = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
answer_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  Answer *self = ANSWER (object);

  switch (property_id)
  {
    case PROP_ANSWER_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_ANSWER_ERROR_MESSAGE:
      g_value_set_string (value, self->error_message);
      break;

    case PROP_ANSWER_ENTITIES:
      g_value_set_boxed (value, self->entities);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
answer_instance_init (Answer * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->code = 0;
  object->__isset_code = FALSE;
  object->error_message = NULL;
  object->__isset_error_message = FALSE;
  object->entities = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_entities = FALSE;
}

static void 
answer_finalize (GObject *object)
{
  Answer *tobject = ANSWER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->error_message != NULL)
  {
    g_free(tobject->error_message);
    tobject->error_message = NULL;
  }
  if (tobject->entities != NULL)
  {
    g_ptr_array_unref (tobject->entities);
    tobject->entities = NULL;
  }
}

static void
answer_class_init (AnswerClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = answer_read;
  struct_class->write = answer_write;

  gobject_class->finalize = answer_finalize;
  gobject_class->get_property = answer_get_property;
  gobject_class->set_property = answer_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ANSWER_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ANSWER_ERROR_MESSAGE,
     g_param_spec_string ("error_message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ANSWER_ENTITIES,
     g_param_spec_boxed ("entities",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
answer_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AnswerClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) answer_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Answer),
      0, /* n_preallocs */
      (GInstanceInitFunc) answer_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AnswerType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

/* reads a d_b_request_ping_args object */
static gint32
d_b_request_ping_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DBRequestPingArgs * this_object = D_B_REQUEST_PING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
d_b_request_ping_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DBRequestPingArgs * this_object = D_B_REQUEST_PING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DBRequestPingArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
d_b_request_ping_args_instance_init (DBRequestPingArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
d_b_request_ping_args_finalize (GObject *object)
{
  DBRequestPingArgs *tobject = D_B_REQUEST_PING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
d_b_request_ping_args_class_init (DBRequestPingArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = d_b_request_ping_args_read;
  struct_class->write = d_b_request_ping_args_write;

  gobject_class->finalize = d_b_request_ping_args_finalize;
}

GType
d_b_request_ping_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DBRequestPingArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) d_b_request_ping_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DBRequestPingArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) d_b_request_ping_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DBRequestPingArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a d_b_request_ping_result object */
static gint32
d_b_request_ping_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DBRequestPingResult * this_object = D_B_REQUEST_PING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
d_b_request_ping_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DBRequestPingResult * this_object = D_B_REQUEST_PING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DBRequestPingResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
d_b_request_ping_result_instance_init (DBRequestPingResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
d_b_request_ping_result_finalize (GObject *object)
{
  DBRequestPingResult *tobject = D_B_REQUEST_PING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
d_b_request_ping_result_class_init (DBRequestPingResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = d_b_request_ping_result_read;
  struct_class->write = d_b_request_ping_result_write;

  gobject_class->finalize = d_b_request_ping_result_finalize;
}

GType
d_b_request_ping_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DBRequestPingResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) d_b_request_ping_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DBRequestPingResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) d_b_request_ping_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DBRequestPingResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DBRequestDoRequestArgsProperties
{
  PROP_D_B_REQUEST_DO_REQUEST_ARGS_0,
  PROP_D_B_REQUEST_DO_REQUEST_ARGS_REQ
};

/* reads a d_b_request_do_request_args object */
static gint32
d_b_request_do_request_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DBRequestDoRequestArgs * this_object = D_B_REQUEST_DO_REQUEST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->req), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_req = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
d_b_request_do_request_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DBRequestDoRequestArgs * this_object = D_B_REQUEST_DO_REQUEST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DBRequestDoRequestArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "req", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->req), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
d_b_request_do_request_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  DBRequestDoRequestArgs *self = D_B_REQUEST_DO_REQUEST_ARGS (object);

  switch (property_id)
  {
    case PROP_D_B_REQUEST_DO_REQUEST_ARGS_REQ:
      if (self->req != NULL)
        g_object_unref (self->req);
      self->req = g_value_dup_object (value);
      self->__isset_req = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
d_b_request_do_request_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  DBRequestDoRequestArgs *self = D_B_REQUEST_DO_REQUEST_ARGS (object);

  switch (property_id)
  {
    case PROP_D_B_REQUEST_DO_REQUEST_ARGS_REQ:
      g_value_set_object (value, self->req);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
d_b_request_do_request_args_instance_init (DBRequestDoRequestArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->req = g_object_new (TYPE_REQUEST, NULL);
  object->__isset_req = FALSE;
}

static void 
d_b_request_do_request_args_finalize (GObject *object)
{
  DBRequestDoRequestArgs *tobject = D_B_REQUEST_DO_REQUEST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->req != NULL)
  {
    g_object_unref(tobject->req);
    tobject->req = NULL;
  }
}

static void
d_b_request_do_request_args_class_init (DBRequestDoRequestArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = d_b_request_do_request_args_read;
  struct_class->write = d_b_request_do_request_args_write;

  gobject_class->finalize = d_b_request_do_request_args_finalize;
  gobject_class->get_property = d_b_request_do_request_args_get_property;
  gobject_class->set_property = d_b_request_do_request_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_D_B_REQUEST_DO_REQUEST_ARGS_REQ,
     g_param_spec_object ("req",
                         NULL,
                         NULL,
                         TYPE_REQUEST,
                         G_PARAM_READWRITE));
}

GType
d_b_request_do_request_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DBRequestDoRequestArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) d_b_request_do_request_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DBRequestDoRequestArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) d_b_request_do_request_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DBRequestDoRequestArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _DBRequestDoRequestResultProperties
{
  PROP_D_B_REQUEST_DO_REQUEST_RESULT_0,
  PROP_D_B_REQUEST_DO_REQUEST_RESULT_SUCCESS
};

/* reads a d_b_request_do_request_result object */
static gint32
d_b_request_do_request_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DBRequestDoRequestResult * this_object = D_B_REQUEST_DO_REQUEST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
d_b_request_do_request_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DBRequestDoRequestResult * this_object = D_B_REQUEST_DO_REQUEST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DBRequestDoRequestResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
d_b_request_do_request_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  DBRequestDoRequestResult *self = D_B_REQUEST_DO_REQUEST_RESULT (object);

  switch (property_id)
  {
    case PROP_D_B_REQUEST_DO_REQUEST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
d_b_request_do_request_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  DBRequestDoRequestResult *self = D_B_REQUEST_DO_REQUEST_RESULT (object);

  switch (property_id)
  {
    case PROP_D_B_REQUEST_DO_REQUEST_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
d_b_request_do_request_result_instance_init (DBRequestDoRequestResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_ANSWER, NULL);
  object->__isset_success = FALSE;
}

static void 
d_b_request_do_request_result_finalize (GObject *object)
{
  DBRequestDoRequestResult *tobject = D_B_REQUEST_DO_REQUEST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
d_b_request_do_request_result_class_init (DBRequestDoRequestResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = d_b_request_do_request_result_read;
  struct_class->write = d_b_request_do_request_result_write;

  gobject_class->finalize = d_b_request_do_request_result_finalize;
  gobject_class->get_property = d_b_request_do_request_result_get_property;
  gobject_class->set_property = d_b_request_do_request_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_D_B_REQUEST_DO_REQUEST_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_ANSWER,
                         G_PARAM_READWRITE));
}

GType
d_b_request_do_request_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DBRequestDoRequestResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) d_b_request_do_request_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DBRequestDoRequestResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) d_b_request_do_request_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DBRequestDoRequestResultType",
                                   &type_info, 0);
  }

  return type;
}

